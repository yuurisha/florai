import {
  collection,
  addDoc,
  getDocs,
  where,
  updateDoc,
  query,
  orderBy,
  runTransaction,
  doc,
  serverTimestamp,
  deleteDoc,
} from "firebase/firestore";
import { db } from "../lib/firebaseConfig";
import { auth } from "../lib/firebaseConfig";
import type { Event, EventInterest } from "../models/Event";

/**
 * Create a new event
 * - createdBy + createdById derived from auth (NOT client input)
 * - timestamps generated by Firestore
 */
export async function createEvent(
  event: Omit<
    Event,
    "id" | "createdAt" | "interestedUsers" | "notInterestedUsers" | "createdBy" | "createdById" | "status"
  >
) {
  const user = auth.currentUser;
  if (!user) throw new Error("User not authenticated");

  const sanitizedEvent = Object.fromEntries(
  Object.entries(event).filter(([, value]) => value !== undefined)
);

const eventData = {
  ...sanitizedEvent,
  createdBy: user.displayName || user.email || "Anonymous",
  createdById: user.uid,
  createdAt: serverTimestamp(),
  interestedUsers: [],
  notInterestedUsers: [],
  status: "pending",
};
  await addDoc(collection(db, "events"), eventData);
}

/**
 * Get all events (ordered by date created)
 * Filtering is client-side for now (fast to implement, easy to migrate later)
 */
export async function fetchApprovedEvents(): Promise<Event[]> {
  const q = query(
  collection(db, "events"),
  where("status", "==", "approved"),
  orderBy("createdAt", "desc")
);
  const snapshot = await getDocs(q);

 return snapshot.docs.map((docSnap) => {
  const data = docSnap.data() as any;

  return {
    id: docSnap.id,
    ...data,
    createdAt: data.createdAt?.toDate
      ? data.createdAt.toDate().toISOString()
      : data.createdAt,
  } as Event;
});

}

/**
 * Toggle interest status using Firestore transaction
 * Prevents race conditions & double states
 */
export async function toggleEventInterest(
  eventId: string,
  status: EventInterest["status"]
) {
  const user = auth.currentUser;
  if (!user) throw new Error("User not authenticated");

  const eventRef = doc(db, "events", eventId);

  await runTransaction(db, async (transaction) => {
    const snapshot = await transaction.get(eventRef);
    if (!snapshot.exists()) {
      throw new Error("Event not found");
    }

    const data = snapshot.data();
    const userId = user.uid;

    let interestedUsers: string[] = data.interestedUsers || [];
    let notInterestedUsers: string[] = data.notInterestedUsers || [];

    // Remove user from both arrays
    interestedUsers = interestedUsers.filter((id) => id !== userId);
    notInterestedUsers = notInterestedUsers.filter((id) => id !== userId);

    // Apply new status
    if (status === "interested") {
      interestedUsers.push(userId);
    } else if (status === "not-interested") {
      notInterestedUsers.push(userId);
    }

    transaction.update(eventRef, {
      interestedUsers,
      notInterestedUsers,
    });
  });
}


//ADMIN FUNCTIONALITIES//
export async function fetchAllEventsAdmin(): Promise<Event[]> {
  const q = query(
    collection(db, "events"),
    orderBy("createdAt", "desc")
  );

  const snapshot = await getDocs(q);

  return snapshot.docs.map((docSnap) => {
    const data = docSnap.data() as any;

    return {
      id: docSnap.id,
      ...data,
      createdAt: data.createdAt?.toDate
        ? data.createdAt.toDate().toISOString()
        : data.createdAt,
    } as Event;
  });
}

export async function approveEvent(eventId: string) {
  const user = auth.currentUser
  if (!user) throw new Error("Not authenticated")

  // OPTIONAL: check admin role here
  await updateDoc(doc(db, "events", eventId), {
    status: "approved",
  })
}

export async function rejectEvent(eventId: string) {
  const user = auth.currentUser
  if (!user) throw new Error("Not authenticated")

  await updateDoc(doc(db, "events", eventId), {
    status: "rejected",
  })
}

export async function deleteEvent(eventId: string) {
  const user = auth.currentUser
  if (!user) throw new Error("Not authenticated")

  // OPTIONAL: check admin role here
  await deleteDoc(doc(db, "events", eventId))
}
